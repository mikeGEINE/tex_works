% !TEX program = xelatex

\documentclass[a4paper, 14pt]{article}
\usepackage{bmstu-lab}
\hypersetup{
    linkcolor=black
}
\usepackage[english,russian]{babel}
% \usepackage{showframe}


\begin{document}
    \graphicspath{{images/}{images2/}} % папки с картинками
    \renewcommand{\figurename}{Рисунок}

    \worknumber{1}
    \variant{3}
    \workname{Изучение принципов работы микропроцессорного ядра RISC-V}
    \discipline{Организация ЭВМ и систем}
    \group{ИУ6-74Б}
    \author{М.А. Гейне}
    \tutor[Преподаватель]{А.Ю. Попов}
    \bmstutitlelab
    \tolerance=450

    \tableofcontents
    \pagebreak

    \textbf{Цель работы:} основной целью работы является ознакомление с принципами функционирования,
    построения и особенностями архитектуры суперскалярных конвейерных микропроцессоров.
    Дополнительной целью работы является знакомство с принципами проектирования и
    верификации сложных цифровых устройств с использованием языка описания аппаратуры
    SystemVerilog и ПЛИС.
    \section*{Задание}
    \addcontentsline{toc}{section}{\protect\numberline{}Задание}
    В ходе выполнения лабораторной работы необходимо:
    \begin{enumerate}
        \item Провести сборку программы по индивидуальному варианту, изучить её исходный код; 
        \item Изучить процесс выборки и диспетчеризации команды;
        \item Изучить процесс декодирования команды;
        \item Изучить процесс выполнения команды;
        \item Провести анализ выполнения программы по индивидуальному варианту. Провести трассировку программы. 
        Выявить пути для оптимизации, оптимизировать и привести трассировку оптимизированной программы.
    \end{enumerate}
    \pagebreak

    \section{Сборка и изучение программы}
    В соответствии с индивидуальным вариантом была выбрана программа, исходный код которой приведён ниже.
    \codeinsert{'codes/task.s'}
    По результатам сборки был получен следующий дизассемблерный листинг.
    \codeinsert{'codes/task.txt'}
    Изучив исходный код программы был составлен псевдокод, приведённый ниже.
    \codeinsert{'codes/pseudocode'}
    Изучив алгоритм работы программы было установлено, что в конце её выполнения \textbf{x31 = 29}.
    
    \section{Изучение процессов выборки и диспетчеризации}
    В процессе выборки команды происходит выборка из памяти команд по адресу, который записан в PC. Выбранные данные помещаются на линию \textit{fetch\_instruction}.
    Выборка команды занимает один такт, однако может быть приостановлена, если далее по конвейеру данные некому обработать.

    В рамках процесса диспетчеризации выбранные данные на предыдущем шаге помещаются в очередь команд, получая при этом id<8. В случае, если очередь полностью заполнена, выдаётся сигнал, приостанавливающий выборку.

    По индивидуальному варианту была сохранена временная диаграмма выборки и диспетчеризации команды с адресом \\ \textbf{80000014, 1-я итерация}, приведённая на рисунке \ref{fig:task2}.

    \imageinsert{task2}{0.57}{Временная диаграмма выборки и диспетчеризации}{fig:task2}

    \section{Изучение процесса декодирования команды}
    Из очереди команд данные поступают на декодер, где происходит декодирование команды. В рамках этого процесса определяются код операции, 
    исполнительный блок, исходные регистры и регистры назначения, специфические для команды характеристики. Декодирование производится комбинационно и занимает один такт. Следующим тактом производится планирование на выполнение.
    Однако в некоторых случаях можно наблюдать конфликты при выполнении операции, например при параллельной попытке доступа к одному регистру разных исполнительных блоков. В таком случае команда не выдаётся на исполнение, новая команда не выбирается из очереди.

    По индивидуальному варианту была сохранена временная диаграмма декодирования команды с адресом \textbf{80000020, 1-я итерация}, приведённая на рисунке \ref{fig:task3}.

    \imageinsert{task3}{0.3}{Временная диаграмма декодирования}{fig:task3}
    На диаграмме можно наблюдать, что после декодирования и выдачи на исполнение был обнаружен конфликт (выставлен сигнал \textit{rs2\_conflict}). По этой причине сигнал \textit{decode\_advance} снят, новая команда не выбирается из очереди, а уже поступившая на декодер - не подаётся на исполнение.
    После снятия сигнала о конфликте процесс возобновляется.

    \section{Изучение процесса исполнения команды}
    После декодирования команда отдаётся на исполнение. Исполнительный блок определяется сигналом \textit{new\_request[i]}, где i=0,1,2 - номер блока.
    Блоку АЛУ соответствует i=0, блоку обращения к памяти - i=1, блоку ветвления - i=2. 
    
    На АЛУ выполняются арифметические операции. Блок является комбинационным, результат предоставляет в течение 1 такта.
    Блок ветвления предоставляет результат за 1 такт. В случае ошибки предсказания адреса в следующем после поступления на исполнение такте будет выдан сигнал сброса, который приведёт к очистке уже выбранной очереди команд.
    Блок обращения к памяти выполняет запрос за 3 такта. Однако если бы было обращение к внешней памяти, то на его работу потребовалось бы значительно больше тактов.
    
    По индивидуальному варианту была сохранена временная диаграмма выполнения команды с адресом \textbf{80000008}, приведённая на рисунке \ref{fig:task4}.

    \imageinsert{task4}{0.3}{Временная диаграмма выполнения}{fig:task4}

    \section{Трассировка программы}
    На основе полученных знаний была проведена трассировка индивидуальной программы. В ходе выполнения было подтверждено, что \textbf{x31 = 29}.
    Результат трассировки представлен на рисунке \ref{fig:task5_trace}.
    \imageinsert{pipeline}{0.6}{Трассировка программы}{fig:task5_trace}
    Была получена временная диаграмма команды \textbf{add x31, x31, x2} с адресом \textbf{80000010}, приведённая на рисунке \ref{fig:task5}.
    \imageinsert{task5}{0.45}{Временная диаграмма обработки команды}{fig:task5}
    В таблице видно, что после выборки данных из памяти в следующей команде случается конфликт.
    Это происходит из-за того, что в этой команде используется регистр, в который записываются данные из памяти.
    Чтобы избежать конфликта было решено производить выборку нового аргумента перед началом очередной итерации цикла и после обработки предыдущего аргумента. Таким образом, к моменту выполнения команды с конфликтом 
    пройдет достаточное количество тактов для выполнения пересылки из памяти. Однако на первой итерации будет также наблюдаться конфликт.

    В соответствии с приведёнными выше предложениями по оптимизации была составлена оптимизированная программа,\\ текст которой приведён ниже.
    \codeinsert{'codes/optimized_task.s'}
    По результатам сборки был получен следующий дизассемблерный листинг.
    \codeinsert{'codes/task.txt'}
    Была проведена повторная трассировка программы, результат которой отображен на рисунке \ref{fig:task5_trace_optimized}
    \imageinsert{pipeline_optimized}{0.6}{Трассировка оптимизированной программы}{fig:task5_trace_optimized}
    Была получена временная диаграмма команды \textbf{add x31, x31, x2} с адресом \textbf{80000014}, приведённая на рисунке \ref{fig:task5_optimized}.
    \imageinsert{task5_optimized}{0.65}{Временная диаграмма обработки команды}{fig:task5_optimized}
    Из таблицы видно, что конфликты больше не возникают и команды не находятся в ожидании лишние такты.
    В результате оптимизации удалось сократить время выполнения основной части программы с 60 тактов до 48, т.е. на 12 тактов.
    \pagebreak
    \section*{Выводы}
    \addcontentsline{toc}{section}{\protect\numberline{}Выводы}
    В ходе выполнения лабораторной работы были изучены \\ принципы работы микропроцессорного ядра RISC-V.
    
    Изучены процессы выборки, диспетчеризации, декодирования и выполнения команд.

    Проведена трассировка программы, предоставленной по индивидуальному заданию. В ходе трассировки выявлены \\конфликты в выполнении команд.

    Предложены варианты оптимизации программы. В соответствии с ними программа была изменена.

    Проведена трассировка оптимизированной программы. \\Оптимизация позволила избежать конфликтов и увеличить скорость исполнения программы на 12 тактов.
\end{document}